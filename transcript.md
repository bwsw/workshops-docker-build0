# Workshop #1 "Isolating application"

## step 0: WTF?

### Что такое image
Docker image это образ наподобие образов виртуальных машин.
Образы можно заполучить из репозиториев или собрать по Dockerfile.

Образ хранит в себе: содержимое файловой системы, метаданные, значения переменных окружения.

```
$ docker pull ubuntu:16.04
$ docker pull alpine:latest
$ docker images
```

### Что такое Dockerfile

Для создания образов используется Dockerfile - своеобразный сценарий для создания образа.
Данный файл включает в себя различные иснтрукции, извеняющие состояние системы, которое в последствии фиксируется в образе.

Для сборки образа используется команда `docker build`.
 
```
$ cat step0/Dockerfile
$ docker build -t step0 step0
```

### Что такое слои
Образ состоит из слоев. Каждый слой есть результыт выполнения одной команды Dockerfile.

```
$ docker history ubuntu:16.04
```

## Step 1: Syntax

```
# Comment
INSTRUCTION arguments
```

Рассмотрим основные команды Dockerfile:
* `FROM <image:tag>` - выбор базового образа, на основе котрого мы будем сроить свой образ. Всегда идет первой командой.
* `ENV <key>=<value>` - задание значения переменным окружения внутри образа
* `RUN <command>` - выполнение команды в текущем состоянии образа и фиксация результата воздействия на файловую систему или переменные окружения.
* `ADD/COPY <source> <destination>` - добавление в образ файлов извне
* `WORKDIR <path>` - задание стартовой директории для образа
* `VOLUME <path>` - указание точек монтирования в файловой сиситеме образа
* `EXPOSE <port>` - указание портов, которые образ "намеревается" использовать
* `CMD <command>` - указание команды по-умолчанию для запуска образа
* `ENTRYPOINT <command>` - указание команды для запуска образа. В случае использования данной директивы, `CMD` стоит рассматривать как набор аргументов для `ENTRYPOINT`

Набор существующих директив больше. Детально изучить синтаксис Dockerfile можно на оф. сайте: https://docs.docker.com/engine/reference/builder/
 
### Задача

Создадим приложение "hello $lastname".

```
$ cat step1/Dockerfile
$ cat step1/hello.sh
```

**Задание**: сделать образ, при запуске которого, на экране будет появляться приветствие в ваш адрес.
```
$ docker build -t step1 step1
$ docker run --rm -it step1
```

## Step 2: `rm` in Dockerfile
 
Т.к. образ состоит из слоев, данные зафиксированные в одном из влоев не могет быть полностью удалены из образа.
Также как это происходит с однажды закоммиченными в git файлами. 
*Следствие*: чтобы образ не был "тяжелым" нужно думать, какие изменения в файловую систему вносят команды, составляющие Dockerfile.

```
$ docker build -t step2 step2
$ docker images
$ docker history step2
```

### Задача

**Задание**: изменить `step2/Dockerfile` так, чтобы размер образа уменьшился.


## Step 3: ADD vs COPY

COPY копирует фал из контекста в образ. Примеры:
```
COPY dir/ otherDir/
COPY file otherDir/otherFile
COPY file1 file2 otherDir/
COPY file* otherDir/
```

ADD имеет расширенный функционал. 
Он будет распаковывать узнаваемые архивы (gzip, bzip2, xz а также tar):
```
ADD package.tar.gz someDir/
```

Также ADD может скачивать файлы из сети. В этом случае распаковка **не происходит**. Например:
```
ADD http://example.com/file otherDir/otherFile
ADD http://example.com/file otherDir/
```

Что использовать? В 90% случаев функциональность `ADD` не нужна и лучше использовать `COPY`. 

## Step 4: `ENTRYPOINT` vs `CMD`

https://docs.docker.com/engine/reference/builder/#entrypoint

При запуске контейнера docker будет запускать процесс "собирая" `ENTRYPOINT` и `CMD` воедино.

Например, для `step4/Dockerfile` команда `docker run step4` запустит `/bin/hello user`. 

Содержимое `CMD` переписывается аргуметами, указываемыми при запуске после имени образа:

```
$ docker run step4 Andrey
=> Hello, Andrey
```
Использование `ENTRYPOINT` дает удобный интерфейс передачи параметров упакованному приложению.

### Немного о формате

`ENTRYPOINT` и `CMD` (а также `RUN`) могут быть записаны в одном из двух форматов:
* shell-формат: `some foo bar`
* exec-формат: `["executable", "arg1", "arg2", ...]`

В случае shell-формата docker припишет строку к установленному для образа shell'у (для linux это `/bin/sh -c`), 
таким образом по факту в контейнере будет запускаться shell с указанной командой. Это удобно, но для `CMD` может давать непредсказуемый результат, особенно в связке с `ENTRYPOINT`. 
Попробуйте заменить `CMD ["user"]` на `CMD user` в `step4/Dockerfile`.

В случае exec-формата docker будет запускать все точно по заданным параметрам. В нашем случае `ENTRYPOINT` и `CMD` собираются воедино и запускается `/bin/hello user`.

Кстати, используемый shell можно переопределить с помощью директивы `SHELL` (см. [документацию](https://docs.docker.com/engine/reference/builder/#shell)).

## Step 5: `EXPOSE` and `VOLUME`

`EXPOSE xxx` используется для информирования docker'а о том, что данный образ предполагает использовать порт `xxx` для приема входящих подключений.
Несмотря на то, что данная директива несет по большей части информационный характер, не стоит ей пренебрегать.
 
`VOLUME <path>` используется для указания точек монтирования в файловой системе контейнера. 
При последующем запуске контейнера пользователь может замонтировать на данную точку часть файловой системы host-машины или другого контейнера, например:
```
$ docker run -v /path/on/host:/path/in/container imagename
```

Волюмы используются как для передачи данных в контейнер, так и для извлечения их.
По факту docker позволяет писать в любую локацию в файловой системе контейнера. 
Но для путей, которые будут использоваться для записи информации (даже временной/ненужной вроде кэша или логов) лучше объявлять точки монтирования.

### Задача

Создадим образ простого приложения, позволяющего просматривать и скачивать файлы через браузер.

```
$ cat step5/Dockerfile
$ docker build -t step5 step5
$ docekr run --rm -it -v ~/projects/mocean:/data:ro
```

* `EXPOSE 80` мы указываем, что будем слушать на порту 80
* `VOLUME ["/var/log/nginx", "/data"]` мы указываем, что логи и данные мы хотим монтировать извне.
* `browser.conf` - файл настройки http-севера nginx
* `start.sh` - файл запуска по-умолчанию, нужен чтобы показать в консоли IP контейнера 
* `-v ~/projects/mocean:/data:ro` - монтируем папочку для просмотра в браузере

## Step 6: layers, cache and number 42

